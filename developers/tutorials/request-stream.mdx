---
title: Request Stream
description: Send a continuous stream of proof requests to the Boundless Market based on blockchain events.
icon: stream
---

## Overview

The Request Stream pattern demonstrates how to continuously submit proof requests to the Boundless Market based on blockchain events. This is a common pattern for applications that need to prove something about each block or block range, such as monitoring block hashes, tracking state transitions, or verifying computations across multiple blocks.

<Note>
  The Request Stream example source code can be found at: [boundless/examples/request-stream](https://github.com/boundless-xyz/boundless/tree/main/examples/request-stream)
</Note>

## Key Concepts

This tutorial demonstrates:

1. **Stream-based Request Processing**: Using Rust streams to process events asynchronously
2. **Request Construction**: Building proof requests with custom input and request IDs
3. **Request Lifecycle**: Submitting requests and waiting for fulfillment
4. **Storage Provider Integration**: Uploading programs and inputs to external storage

## How It Works

The request stream pattern follows this workflow:

1. Monitor the blockchain for new blocks
2. Every N blocks (configurable, default: 2), collect block hashes
3. Construct a proof request with the block hashes as input
4. Submit the request to the Boundless Market
5. Wait for a prover to fulfill the request
6. Repeat for the next block range

## Setting Up

### Environment Variables

You'll need the same environment variables as a standard request:

```bash
export RPC_URL="https://..."
export PRIVATE_KEY="abcdef..."
export PINATA_JWT="abcdef..."  # or configure S3 storage
```

For more details on storage providers, see [Storage Providers](/developers/tutorials/request#storage-providers).

### CLI Arguments

The request stream example accepts the following arguments:

```rust
struct Args {
    /// URL of the Ethereum RPC endpoint
    rpc_url: Url,
    /// Private key used to interact with the Boundless Market
    private_key: PrivateKeySigner,
    /// Number of blocks to include in each request
    blocks_per_request: u64,  // default: 2
    /// Storage provider configuration
    storage_config: StorageProviderConfig,
    /// Boundless Market deployment (optional)
    deployment: Option<Deployment>,
}
```

## Creating a Block Range Stream

The core of the request stream pattern is creating an async stream that monitors the blockchain and emits events when new block ranges are ready.

### Stream Pattern Benefits

Using a stream provides several advantages:

- **Async processing**: Events are processed as they arrive
- **Backpressure handling**: The consumer controls the rate of processing
- **Composable**: Can be combined with other stream operations (filter, map, etc.)

### Implementation

```rust
async fn create_block_range_stream<P: Provider + Clone + 'static>(
    provider: P,
    blocks_per_request: u64,
) -> Result<Pin<Box<dyn Stream<Item = Result<BlockRangeEvent>> + Send>>> {
    let initial_block = provider.get_block_number().await?;
    let provider = std::sync::Arc::new(provider);
    let provider_clone = provider.clone();

    Ok(Box::pin(async_stream::stream! {
        let mut last_processed_block = initial_block;

        loop {
            let target_block = last_processed_block + blocks_per_request;

            // Poll until we reach the target block
            loop {
                let current_block = provider_clone.get_block_number().await?;
                if current_block >= target_block {
                    break;
                }
                tokio::time::sleep(Duration::from_secs(2)).await;
            }

            // Collect block hashes in the range
            let start_block = last_processed_block + 1;
            let end_block = target_block;
            let mut block_hashes = Vec::new();

            for block_num in start_block..=end_block {
                let block = provider_clone
                    .get_block_by_number(BlockNumberOrTag::Number(block_num))
                    .await?;
                block_hashes.push(block.header.hash);
            }

            yield Ok(BlockRangeEvent {
                start_block,
                end_block,
                block_hashes,
            });

            last_processed_block = end_block;
        }
    }))
}
```

## Processing Events and Submitting Requests

Once you have a stream of block range events, you can process them and submit proof requests:

### Main Processing Loop

```rust
// Create the client
let client = Client::builder()
    .with_rpc_url(args.rpc_url)
    .with_deployment(args.deployment)
    .with_storage_provider_config(&args.storage_config)?
    .with_private_key(args.private_key.clone())
    .build()
    .await?;

// Upload the program once
let program_url = client
    .storage_provider
    .as_ref()
    .unwrap()
    .upload_program(ECHO_ELF)
    .await?;

// Create the event stream
let provider = client.boundless_market.instance().provider().clone();
let mut stream = create_block_range_stream(provider, args.blocks_per_request).await?;

// Process events
while let Some(event_result) = stream.next().await {
    let event = event_result?;

    // Prepare input data
    let input = input_function(&event.block_hashes);
    let request_id = request_id_function(args.private_key.address(), event.start_block);

    // Build and submit the request
    let request = client
        .new_request()
        .with_program_url(program_url.clone())?
        .with_request_input(input)
        .with_request_id(request_id);

    let (submitted_request_id, expires_at) = client.submit(request).await?;

    // Wait for fulfillment
    let _fulfillment = client
        .wait_for_request_fulfillment(
            submitted_request_id,
            Duration::from_secs(5),
            expires_at,
        )
        .await?;
}
```

## Input Construction

The input data must be prepared in a format that your guest program can understand. In this example, we concatenate block hashes:

```rust
fn input_function(block_hashes: &[B256]) -> RequestInput {
    let mut input = Vec::new();
    // Concatenate all block hashes into a single byte vector
    // Each hash is 32 bytes (B256)
    for hash in block_hashes {
        input.extend_from_slice(hash.as_slice());
    }
    RequestInput::builder().write_slice(&input).build_inline().unwrap()
}
```

<Tip>
  In production, you might want to serialize data in a structured format (e.g., using bincode, serde) or include additional metadata. Make sure your guest program knows how to deserialize this format!
</Tip>

## Request IDs

Request IDs in Boundless Market are composed of:
- The requestor's address (your address)
- A 32-bit index (unique identifier for this request)

### Request ID Structure

The request ID is a 256-bit value where:
- Bits 0-31: The index (u32)
- Bits 32-191: The requestor address (160 bits)
- Bits 192+: Flags (e.g., smart contract signature flag)

### Choosing an Index

In this example, we use the start block number as the index:

```rust
fn request_id_function(address: Address, start_block: u64) -> RequestId {
    let request_index = start_block as u32;
    RequestId::new(address, request_index)
}
```

This ensures:
- Each block range gets a unique request ID
- Request IDs are deterministic (same block range = same ID)
- Easy to identify which block range a request corresponds to

<Warning>
  The index must be unique per requestor address. If you submit multiple requests with the same index, only one will be accepted.
</Warning>

## Complete Example

Here's a complete example showing the full workflow:

```rust
async fn run(args: Args) -> Result<()> {
    // Step 1: Create the Boundless client
    let client = Client::builder()
        .with_rpc_url(args.rpc_url)
        .with_deployment(args.deployment)
        .with_storage_provider_config(&args.storage_config)?
        .with_private_key(args.private_key.clone())
        .build()
        .await?;

    // Step 2: Upload the program
    let program_url = client
        .storage_provider
        .as_ref()
        .unwrap()
        .upload_program(ECHO_ELF)
        .await?;

    // Step 3: Create the event stream
    let provider = client.boundless_market.instance().provider().clone();
    let mut stream = create_block_range_stream(provider, args.blocks_per_request).await?;

    // Step 4: Process events and submit requests
    while let Some(event_result) = stream.next().await {
        let event = event_result?;

        // Prepare request data
        let input = input_function(&event.block_hashes);
        let request_id = request_id_function(args.private_key.address(), event.start_block);

        // Build the request
        let request = client
            .new_request()
            .with_program_url(program_url.clone())?
            .with_request_input(input)
            .with_request_id(request_id);

        // Submit the request
        let (request_id, expires_at) = client.submit(request).await?;

        // Wait for fulfillment
        let fulfillment = client
            .wait_for_request_fulfillment(
                request_id,
                Duration::from_secs(5),
                expires_at,
            )
            .await?;

        tracing::info!("Request fulfilled: {:?}", fulfillment);
    }

    Ok(())
}
```

## Use Cases

The request stream pattern is ideal for:

- **Block monitoring**: Proving properties about each block or block range
- **State verification**: Continuously verifying state transitions
- **Batch processing**: Processing data in batches as new blocks arrive
- **Real-time proofs**: Generating proofs for events as they occur on-chain

## Next Steps

- Learn about [request configuration](/developers/tutorials/request#request-configuration) for fine-tuning your requests
- Explore [using proofs](/developers/tutorials/use) in your application
- Check out [callbacks](/developers/tutorials/callbacks) for automatic proof delivery
