---
title: Boundless SDK
description: An overview of the Boundless SDK for requestors.
icon: code
---

## Overview

The Boundless Market SDK offers high-level Rust APIs for interacting with the Boundless Market smart contracts, preparing and submitting ZK proofs, and handling relevant offchain data such as images and inputs.

[Crate Documentation](https://docs.rs/boundless-market/latest/boundless_market/#boundless-market-sdk)

## Installation

```bash
cargo add boundless-market
```

or add manually to your Cargo.toml:

```toml
[dependencies]
boundless-market = "X.X.X"
```
where X.X.X is the latest release specified on the [Boundless GitHub Release](https://github.com/boundless-xyz/boundless/releases) page.

## SDK Workflow Overview

Below is an example of the **Boundless** end-to-end programmatic workflow:

### 1. Initialize Client

```rust
use boundless_market::Client;
use alloy::signers::local::LocalSigner;
let client = Client::builder()
    .with_rpc_url(rpc_url)
    .with_private_key(LocalSigner::random())
    .build()
    .await?;
```

### 2. Upload Program and Input

```rust
let program_url = client.upload_program(&std::fs::read("guest.bin")?).await?;
let input_url = client.upload_input(&[0x41, 0x42, 0x43]).await?;
```

### 3. Submit Proof Request

```rust
let (request_id, expires_at) = client.submit_request_onchain(&request).await?;
```

### 4. Await Fulfillment

```rust
let fulfillment = client
    .wait_for_request_fulfillment(request_id, Duration::from_secs(10), expires_at)
    .await?;

```

### 5. Fetch Proof Results

```rust
// If not using wait_for_request_fulfillment:
let fulfillment = client.boundless_market.get_request_fulfillment(request_id).await?;

// Advanced: Set-Inclusion Receipt
let (journal, receipt) = client.fetch_set_inclusion_receipt(request_id, [0u8; 32].into()).await?;
```

## SDK Modules

### `client`
- `Client`: Core struct for transactions, storage, and offchain interaction.

### `contracts`
- `BoundlessMarketService`: Onchain interactions (requests, fulfillments, deposits).
- `SetVerifierService`: Manages aggregated proof verifications.
- Structures: `ProofRequest`, `Offer`, `Fulfillment`.

### `input`
- `GuestEnv`: Environment for the guest, including input (e.g. `stdin`)

### `order_stream_client`
- `OrderStreamClient`: Submit/fetch orders offchain via WebSocket.

### `storage`
- Providers: `S3` and `Pinata` for uploading program and input data.

### `selector`
- Utilities for tracking/verifying proof types.

## Example: Full Proof Submission

```rust
use boundless_market::{
  Client,
  contracts::{FulfillmentData, RequestId, Requirements, Predicate, Offer},
  storage::storage_provider_from_env,
  request_builder::OfferParams,
};
use alloy::signers::local::PrivateKeySigner;
use alloy::primitives::U256;
use std::time::Duration;
use url::Url;

async fn proof_submission(signer: &PrivateKeySigner, rpc_url: Url) -> anyhow::Result<()> {
    let client = Client::builder()
        .with_rpc_url(rpc_url)
        .with_private_key(signer.clone())
        .with_storage_provider(Some(storage_provider_from_env()?))
        .build()
        .await?;

    // Build the request.
    let request = client.new_request()
        .with_program(std::fs::read("guest.bin")?)
        .with_stdin(42u32.to_le_bytes());

    // Submit the request.
    let (request_id, expires_at) = client.submit(request).await?;

    let fulfillment = client
        .wait_for_request_fulfillment(request_id, Duration::from_secs(10), expires_at)
        .await?;
    println!("FulfillmentData: {:?}, Seal: {:?}", fulfillment.data()?, fulfillment.seal);

    Ok(())
}
```
