// ---------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
//
// This file is automatically generated by `build.rs`. It collects all Rust
// code snippets from the `.mdx` documentation files and turns them into
// runnable tests.
//
// Any manual edits will be overwritten on the next `cargo build` or `cargo test`.
//
// To make changes, edit the Rust snippets in the `.mdx` files directly.
// ---------------------------------------------------------------------------
#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn proof_lifecycle_mdx_0_test() {
use std::time::Duration;
use boundless_market::{Client, storage::storage_provider_from_env};
use alloy::signers::local::LocalSigner;
use boundless_market::contracts::ProofRequest;
async fn submit_request(request: ProofRequest) -> Result<(), Box<dyn std::error::Error>> {
let boundless_client = Client::builder()
.with_private_key(LocalSigner::random())
.with_storage_provider(Some(storage_provider_from_env()?))
.build()
.await?;
let (request_id, expires_at) = boundless_client.submit_request_onchain(&request).await?;
let fulfillment = boundless_client
  .wait_for_request_fulfillment(
    request_id,
    Duration::from_secs(5),
    expires_at,
  )
  .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn commitments_mdx_0_test() {
use alloy::providers::ProviderBuilder;
use risc0_steel::{ethereum::{EthEvmEnv, ETH_SEPOLIA_CHAIN_SPEC}};
use url::Url;
async fn preflight(rpc_url: Url) -> Result<(), Box<dyn std::error::Error>> {
let provider = ProviderBuilder::new().connect_http(rpc_url);
// Create an EVM environment from that provider
let mut env = EthEvmEnv::builder()
    .chain_spec(&ETH_SEPOLIA_CHAIN_SPEC)
    .provider(provider.clone())
    .block_number(20842508)
    .build()
    .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn commitments_mdx_1_test() {
use alloy::providers::ProviderBuilder;
use risc0_steel::{ethereum::{EthEvmEnv, ETH_SEPOLIA_CHAIN_SPEC}};
use url::Url;
async fn preflight(rpc_url: Url) -> Result<(), Box<dyn std::error::Error>> {
let provider = ProviderBuilder::new().connect_http(rpc_url);
let mut env = EthEvmEnv::builder()
.chain_spec(&ETH_SEPOLIA_CHAIN_SPEC)
.provider(provider.clone())
.block_number(20842508)
.build()
.await?;
let evm_input = env.into_input().await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn commitments_mdx_2_test() {
use alloy::primitives::Address;
use risc0_steel::{ethereum::{EthEvmInput, ETH_SEPOLIA_CHAIN_SPEC}};
use risc0_zkvm::guest::env;
fn commitment() {
// Read the input from the guest environment.
let input: EthEvmInput = env::read();
let contract: Address = env::read();
let account: Address = env::read();
// Converts the input into a `EvmEnv`
let env = input.into_env(&ETH_SEPOLIA_CHAIN_SPEC);
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn commitments_mdx_3_test() {
use alloy::primitives::Address;
use alloy::sol_types::SolValue;
use risc0_steel::{Commitment, ethereum::{EthEvmInput, ETH_SEPOLIA_CHAIN_SPEC}};
use risc0_zkvm::guest::env;
alloy::sol! {
struct Journal {
Commitment commitment;
address tokenAddress;
}
}
fn commitment(input: EthEvmInput, contract: Address) {
let evm_env = input.into_env(&ETH_SEPOLIA_CHAIN_SPEC);
    // Commit the block hash and number used when deriving `view_call_env` to the journal.
let journal = Journal {
    commitment: evm_env.into_commitment(),
    tokenAddress: contract,
};
env::commit_slice(&journal.abi_encode());
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn history_mdx_0_test() {
use alloy::providers::ProviderBuilder;
use alloy::primitives::Address;
use risc0_steel::{ethereum::{EthEvmEnv, ETH_MAINNET_CHAIN_SPEC}, host::BlockNumberOrTag, Contract};
use url::Url;
async fn preflight(latest: u64, beacon_api_url: Url, rpc_url: Url) -> Result<(), Box<dyn std::error::Error>> {
let provider = ProviderBuilder::new().connect_http(rpc_url);
let token_contract = Address::ZERO;
let builder = EthEvmEnv::builder()
    .provider(&provider)
    .block_number(latest - 8191) // execution block
    .beacon_api(beacon_api_url)
    .commitment_block_number(latest - 1) // Steel commitment block
    .chain_spec(&ETH_MAINNET_CHAIN_SPEC);
let mut env = builder.build().await?;
// Preflight the call at the execution block.
let mut contract = Contract::preflight(token_contract, &mut env);
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn how_it_works_mdx_0_test() {
alloy::sol!(
    interface IERC20 {
        function balanceOf(address account) external view returns (uint);
}
);
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn how_it_works_mdx_1_test() {
use alloy::primitives::{Address, U256};
use alloy::sol_types::SolValue;
use boundless_market::contracts::token::IERC20;
use risc0_steel::{Commitment, Contract, ethereum::{EthEvmInput, ETH_SEPOLIA_CHAIN_SPEC}};
use risc0_zkvm::guest::env;
alloy::sol! {
struct Journal {
Commitment commitment;
address tokenAddress;
}
}
fn commitment() {
// GUEST PROGRAM
// Read the input from the guest environment.
let input: EthEvmInput = env::read();
let contract: Address = env::read();
let account: Address = env::read();
let evm_env = input.into_env(&ETH_SEPOLIA_CHAIN_SPEC);
// Execute the view call; it returns the result in the type generated by the `sol!` macro.
let call = IERC20::balanceOfCall { account };
let balance = Contract::new(contract, &evm_env)
  .call_builder(&call)
  .call();
// Check that the given account holds at least 1 token.
assert!(balance >= U256::from(1));
// Commit the block hash and number used when deriving `view_call_env` to the journal.
let journal = Journal {
    commitment: evm_env.into_commitment(),
    tokenAddress: contract,
};
env::commit_slice(&journal.abi_encode());
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn how_it_works_mdx_2_test() {
use alloy::providers::ProviderBuilder;
use alloy::primitives::Address;
use risc0_steel::{ethereum::{EthEvmEnv, ETH_SEPOLIA_CHAIN_SPEC}, Contract};
use url::Url;
async fn preflight(eth_rpc_url: Url, token_contract: Address) -> Result<(), Box<dyn std::error::Error>> {
// HOST PROGRAM
// Create an alloy provider from RPC URL
let provider = ProviderBuilder::new()
    .connect_http(eth_rpc_url);
// Create an EVM environment from that provider defaulting to the latest block.
let mut env = EthEvmEnv::builder()
    .chain_spec(&ETH_SEPOLIA_CHAIN_SPEC)
    .provider(provider.clone())
    .build()
    .await?;
// Preflight the call to prepare the input that is required to execute the function in the guest without RPC access.
let mut contract = Contract::preflight(token_contract, &mut env);
let evm_input = env.into_input().await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn sdk_mdx_0_test() {
use boundless_market::Client;
use alloy::signers::local::LocalSigner;
use url::Url;
async fn init_client(rpc_url: Url) -> anyhow::Result<()> {
let client = Client::builder()
    .with_rpc_url(rpc_url)
    .with_private_key(LocalSigner::random())
    .build()
    .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn sdk_mdx_1_test() {
use boundless_market::{Client, storage::storage_provider_from_env};
use alloy::signers::local::LocalSigner;
use url::Url;
async fn upload_program_and_input(rpc_url: Url) -> anyhow::Result<()> {
let client = Client::builder()
.with_rpc_url(rpc_url)
.with_private_key(LocalSigner::random())
.with_storage_provider(Some(storage_provider_from_env()?))
.build()
.await?;
let program_url = client.upload_program(&std::fs::read("guest.bin")?).await?;
let input_url = client.upload_input(&[0x41, 0x42, 0x43]).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn sdk_mdx_2_test() {
use boundless_market::Client;
use boundless_market::contracts::ProofRequest;
async fn submit_request(client: Client, request: ProofRequest) -> anyhow::Result<()>
{
let (request_id, expires_at) = client.submit_request_onchain(&request).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn sdk_mdx_3_test() {
use std::time::Duration;
use boundless_market::Client;
use boundless_market::contracts::ProofRequest;
async fn submit_request(client: Client, request: ProofRequest) -> anyhow::Result<()>
{
let (request_id, expires_at) = client.submit_request_onchain(&request).await?;
let fulfillment = client
    .wait_for_request_fulfillment(request_id, Duration::from_secs(10), expires_at)
    .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn sdk_mdx_4_test() {
use alloy::primitives::U256;
use boundless_market::Client;
async fn fetch_results(client: Client, request_id: U256) -> anyhow::Result<()>
{
// If not using wait_for_request_fulfillment:
let fulfillment = client.boundless_market.get_request_fulfillment(request_id).await?;
// Advanced: Set-Inclusion Receipt
let (journal, receipt) = client.fetch_set_inclusion_receipt(request_id, [0u8; 32].into()).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn sdk_mdx_5_test() {
use boundless_market::{
  Client,
  contracts::{FulfillmentData, RequestId, Requirements, Predicate, Offer},
  storage::storage_provider_from_env,
  request_builder::OfferParams,
};
use alloy::signers::local::PrivateKeySigner;
use alloy::primitives::U256;
use std::time::Duration;
use url::Url;
async fn proof_submission(signer: &PrivateKeySigner, rpc_url: Url) -> anyhow::Result<()> {
    let client = Client::builder()
        .with_rpc_url(rpc_url)
        .with_private_key(signer.clone())
        .with_storage_provider(Some(storage_provider_from_env()?))
        .build()
        .await?;
    // Build the request.
    let request = client.new_request()
        .with_program(std::fs::read("guest.bin")?)
        .with_stdin(42u32.to_le_bytes())
        .with_offer(OfferParams::builder()
            .ramp_up_period(30)
            .lock_timeout(150)
            .timeout(300)
        );
    // Submit the request onchain.
    let (request_id, expires_at) = client.submit_onchain(request).await?;
    let fulfillment = client
        .wait_for_request_fulfillment(request_id, Duration::from_secs(10), expires_at)
        .await?;
    println!("FulfillmentData: {:?}, Seal: {:?}", fulfillment.data()?, fulfillment.seal);
    Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn build_mdx_0_test() {
use std::io::Read;
use alloy_primitives::U256;
use alloy_sol_types::SolValue;
use risc0_zkvm::guest::env;
fn main() {
    // Read the input data for this application.
    let mut input_bytes = Vec::<u8>::new();
    env::stdin().read_to_end(&mut input_bytes).unwrap();
    // Decode and parse the input
    let number = <U256>::abi_decode(&input_bytes).unwrap();
    // Run the computation.
    // In this case, asserting that the provided number is even.
    assert!(!number.bit(0), "number is not even");
    // Commit the journal that will be received by the application contract.
    // Journal is encoded using Solidity ABI for easy decoding in the app contract.
    env::commit_slice(number.abi_encode().as_slice());
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn build_mdx_1_test() {
use std::io::Read;
use alloy_primitives::U256;
use alloy_sol_types::SolValue;
use risc0_zkvm::guest::env;
fn main() {
    // Read the input data for this application.
    let mut input_bytes = Vec::<u8>::new();
    env::stdin().read_to_end(&mut input_bytes).unwrap();
    // Decode and parse the input
    let number = <U256>::abi_decode(&input_bytes).unwrap();
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn build_mdx_2_test() {
use std::io::Read;
use alloy_primitives::U256;
use alloy_sol_types::SolValue;
use risc0_zkvm::guest::env;
fn main() {
let mut input_bytes = Vec::<u8>::new();
env::stdin().read_to_end(&mut input_bytes).unwrap();
let number = <U256>::abi_decode(&input_bytes).unwrap();
    // Run the computation.
    // In this case, asserting that the provided number is even.
    assert!(!number.bit(0), "number is not even");
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn build_mdx_3_test() {
use std::io::Read;
use alloy_primitives::U256;
use alloy_sol_types::SolValue;
use risc0_zkvm::guest::env;
fn main() {
let mut input_bytes = Vec::<u8>::new();
env::stdin().read_to_end(&mut input_bytes).unwrap();
let number = <U256>::abi_decode(&input_bytes).unwrap();
    // Commit the journal that will be received by the application contract. [!code focus]
    // Journal is encoded using Solidity ABI for easy decoding in the app contract. [!code focus]
    env::commit_slice(number.abi_encode().as_slice());
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn callbacks_mdx_0_test() {
use alloy::primitives::address;
use alloy_primitives::utils::parse_ether;
use boundless_market::{Client, request_builder::{OfferParams, RequirementParams}};
use risc0_zkvm::sha::Digest;
async fn create_callback_request(client: Client, program: &'static [u8], input: &[u8]) -> anyhow::Result<()> {
let counter_address = address!("0x000000000000000000000000000000000c0077e5");
let request = client.new_request()
    .with_program(program)
    .with_stdin(input)
    .with_requirements(
        RequirementParams::builder()
            .callback_address(counter_address)
            .callback_gas_limit(100_000)
    )
    .with_offer(
        OfferParams::builder()
            .min_price(parse_ether("0.001")?)
            .max_price(parse_ether("0.002")?)
            .timeout(1000)
            .lock_timeout(1000)
            .ramp_up_period(100)
    );
// Submit the request onchain
let (request_id, expires_at) = client.submit_onchain(request).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn callbacks_mdx_1_test() {
use std::time::Duration;
use alloy::primitives::address;
use boundless_market::Client;
use alloy::sol_types::SolCall;
async fn check_counter(client: Client, request_id: alloy::primitives::U256, expires_at: u64) -> anyhow::Result<()> {
alloy::sol! {
    #[sol(rpc)]
    interface ICounter {
        function count() external view returns (uint256);
    }
}
let fulfillment =
    client.wait_for_request_fulfillment(request_id, Duration::from_secs(5), expires_at).await?;
// We interact with the Counter contract by calling the getCount function to check that the callback
// was executed correctly.
let counter_address = address!("0x000000000000000000000000000000000c0077e5");
let counter = ICounter::ICounterInstance::new(counter_address, client.provider().clone());
let count = counter
    .count()
    .call()
    .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn proof_composition_mdx_0_test() {
use boundless_market::contracts::{Predicate, Requirements};
use risc0_zkvm::sha::Digestible;
let image_id = [0u8; 32];
let journal = Vec::<u8>::new();
let groth16 = true;
let mut requirements = Requirements::new(Predicate::digest_match(image_id, journal.digest()));
if groth16 {
    requirements = requirements.with_groth16_proof();
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn proof_composition_mdx_1_test() {
use alloy::{providers::Provider, network::Ethereum};
use anyhow::Context;
use boundless_market::{client::Client, contracts::RequestInput, input::GuestEnv};
use risc0_zkvm::sha::{Digest, Digestible};
use boundless_market::storage::StorageProvider;
async fn boundless_proof<P, S>(
client: &Client<P, S>,
program: impl AsRef<[u8]>,
guest_env: GuestEnv,
groth16: bool,
) -> anyhow::Result<(Vec<u8>, Vec<u8>)>
where
P: Provider<Ethereum> + 'static + Clone,
S: StorageProvider,
{ unimplemented!() }
async fn run<P, S>(
boundless_client: Client<P, S>
) -> anyhow::Result<()>
where
P: Provider<Ethereum> + 'static + Clone,
S: StorageProvider + Clone,
{
let ECHO_ID = [0u8; 32];
let IDENTITY_ELF = b"";
let echo_receipt = b"";
// Build the IDENTITY input from the ECHO receipt
let identity_input = (Digest::from(ECHO_ID), echo_receipt);
let identity_guest_env =
    RequestInput::builder().write_frame(&postcard::to_allocvec(&identity_input)?).build_env();
// Request a proof from the Boundless market using the IDENTITY guest
let (identity_journal, identity_seal) =
    boundless_proof(&boundless_client, IDENTITY_ELF, identity_guest_env, false)
        .await
        .context("failed to prove IDENTITY")?;
anyhow::Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn proof_composition_mdx_2_test() {
use boundless_market::{client::Client, contracts::ProofRequest};
use risc0_zkvm::sha::{Digest, Digestible};
use alloy::{
network::Ethereum,
primitives::{utils::parse_ether, address, Address, Bytes, B256},
providers::Provider,
signers::local::PrivateKeySigner,
sol_types::SolCall,
};
use std::time::Duration;
alloy::sol! {
    #[sol(rpc)]
    interface ICounter {
        function increment(bytes calldata seal, bytes32 imageId, bytes32 journalDigest) external;
    }
}
async fn interact(request: ProofRequest) -> anyhow::Result<()> {
let boundless_client = Client::builder().build().await?;
let identity_journal = Vec::<u8>::new();
let identity_seal = Bytes::new();
let IDENTITY_ID = [0u8; 32];
let TX_TIMEOUT = Duration::from_secs(30);
// Interact with the Counter contract using the composed proof
let counter_address = address!("0x000000000000000000000000000000000c0077e5");
let counter = ICounter::ICounterInstance::new(counter_address, boundless_client.provider().clone());
let journal_digest = B256::from_slice(identity_journal.digest().as_bytes());
let image_id = B256::from_slice(Digest::from(IDENTITY_ID).as_bytes());
let call_increment =
    counter.increment(identity_seal, image_id, journal_digest).from(boundless_client.caller());
// Execute the transaction
let pending_tx = call_increment.send().await?;
let tx_hash = pending_tx
    .with_timeout(Some(TX_TIMEOUT))
    .watch()
    .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn proof_types_mdx_0_test() {
use alloy_primitives::utils::parse_ether;
use boundless_market::{Client, request_builder::OfferParams};
use url::Url;
async fn create_groth16_request(
client: Client,
program: &'static [u8],
input: &[u8]
) -> anyhow::Result<()> {
let request = client.new_request()
    .with_program(program)
    .with_stdin(input)
    .with_groth16_proof()  // Request raw Groth16 proof
    .with_offer(
        OfferParams::builder()
            .min_price(parse_ether("0.001")?)
            .max_price(parse_ether("0.002")?)
            .timeout(1000)
            .lock_timeout(1000)
    );
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn proof_types_mdx_1_test() {
use alloy_primitives::utils::parse_ether;
use boundless_market::{Client, request_builder::OfferParams};
use url::Url;
async fn create_groth16_request(
client: Client,
program: &'static [u8],
input: &[u8]
) -> anyhow::Result<()> {
let request = client.new_request()
    .with_program(program)
    .with_stdin(input)
    .with_groth16_proof()  // Request raw Groth16 proof
    .with_offer(
        OfferParams::builder()
            .min_price(parse_ether("0.001")?)
            .max_price(parse_ether("0.002")?)
            .timeout(1000)
            .lock_timeout(1000)
    );
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn proof_types_mdx_2_test() {
use risc0_zkvm::guest::env;
use risc0_zkvm::{Digest, Receipt};
fn main() {
    let (image_id, receipt): (Digest, Receipt) = env::read();
    let claim = receipt.claim().unwrap();
    receipt.verify(image_id).unwrap();
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_0_test() {
use alloy::signers::local::PrivateKeySigner;
use boundless_market::{Client, storage::storage_provider_from_env};
use url::Url;
#[derive(Clone)]
struct Args {
rpc_url: Url,
private_key: PrivateKeySigner,
storage_config: String,
}
async fn create_boundless_client() -> Result<(), Box<dyn std::error::Error>> {
let args = Args {
rpc_url: "https://example.com".parse()?,
private_key: "0x0000000000000000000000000000000000000000000000000000000000000001".parse()?,
storage_config: "mock".to_string(),
};
let client = Client::builder()
  .with_rpc_url(args.rpc_url)
  .with_private_key(args.private_key)
  .with_storage_provider(Some(storage_provider_from_env()?))
  .build()
  .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_1_test() {
use anyhow::Result;
use boundless_market::{Client};
async fn create_proof_request(
client: Client,
program: &'static [u8],
input: &[u8]) -> Result<()> {
// In a real application, ECHO_ELF would come from guest_util::ECHO_ELF
let ECHO_ELF = program;
let echo_message = "Hello, world!";
// Create a request using new_request
let request = client.new_request().with_program(ECHO_ELF).with_stdin(echo_message.as_bytes());
// Submit the request onchain, via a transaction
let (request_id, expires_at) = client.submit_onchain(request).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_2_test() {
use std::time::Duration;
use anyhow::Result;
use boundless_market::Client;
use alloy_primitives::U256;
async fn wait_for_fulfillment(
client: Client,
request_id: U256,
expires_at: u64) -> Result<()> {
// Wait for the request to be fulfilled. The market will return the fulfillment.
tracing::info!("Waiting for request {:x} to be fulfilled", request_id);
let fulfillment = client
    .wait_for_request_fulfillment(
        request_id,
        Duration::from_secs(5), // check every 5 seconds
        expires_at,
    )
    .await?;
tracing::info!("Request {:x} fulfilled", request_id);
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_3_test() {
use alloy::signers::local::PrivateKeySigner;
use boundless_market::{Client, storage::storage_provider_from_env};
use url::Url;
#[derive(Clone)]
struct Args {
rpc_url: Url,
private_key: PrivateKeySigner,
storage_config: String,
}
async fn create_boundless_client() -> Result<(), Box<dyn std::error::Error>> {
let args = Args {
rpc_url: "https://example.com".parse()?,
private_key: "0x0000000000000000000000000000000000000000000000000000000000000001".parse()?,
storage_config: "mock".to_string(),
};
let client = Client::builder()
  .with_rpc_url(args.rpc_url)
  .with_private_key(args.private_key)
  .with_storage_provider(Some(storage_provider_from_env()?)) // [!code hl]
  .build()
  .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_4_test() {
use boundless_market::{Client, storage::storage_provider_from_env};
async fn upload_program(program: &[u8]) -> Result<(), Box<dyn std::error::Error>> {
let client = Client::builder()
  .with_storage_provider(Some(storage_provider_from_env()?))
  .build()
  .await?;
let program_url = client.upload_program(program).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_5_test() {
use boundless_market::Client;
async fn create_request_with_urls(
client: &Client,
program_url: &str,
input_url: &str) -> Result<(), Box<dyn std::error::Error>> {
let request = client.new_request()
  .with_program_url(program_url)?
  .with_input_url(input_url);
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_6_test() {
use anyhow::Result;
use boundless_market::{Client};
async fn create_proof_request(
client: Client,
input: &[u8]) -> Result<()> {
mod guest_util {
pub const ECHO_ELF: &[u8] = b"";
}
// Import ECHO_ELF from your guest code
use guest_util::{ECHO_ELF};
// Create a request using new_request
let request = client.new_request()
  .with_program(ECHO_ELF)
  .with_stdin(b"Hello, world!");
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_7_test() {
use boundless_market::{Client, storage::storage_provider_from_env};
async fn upload_input(input_bytes: Vec<u8>) -> Result<(), Box<dyn std::error::Error>> {
let client = Client::builder()
.with_storage_provider(Some(storage_provider_from_env()?))
.build()
.await?;
let input_url = client.upload_input(&input_bytes).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_8_test() {
use anyhow::Result;
use boundless_market::{Client};
async fn create_proof_request(
client: Client,
program: &'static [u8],
input: &[u8]) -> Result<()> {
let ECHO_ELF = program;
let echo_message = "Hello, world!";
// Create a request using new_request
let request = client.new_request().with_program(ECHO_ELF).with_stdin(echo_message.as_bytes()); // [!code hl]
// Submit the request directly
let (request_id, expires_at) = client.submit_onchain(request).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_9_test() {
use anyhow::Result;
use boundless_market::{Client};
async fn create_proof_request(
client: Client,
program: &'static [u8],
input: &[u8]) -> Result<()> {
let ECHO_ELF = program;
let echo_message = "Hello, world!";
// Create a request using new_request
let request = client.new_request().with_program(ECHO_ELF).with_stdin(echo_message.as_bytes());
// Submit the request directly
let (request_id, expires_at) = client.submit_onchain(request).await?; // [!code hl]
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_10_test() {
use anyhow::Result;
use boundless_market::{Client};
async fn create_proof_request(
client: Client,
program: &'static [u8],
input: &[u8]) -> Result<()> {
let ECHO_ELF = program;
let echo_message = "Hello, world!";
// Create a request using new_request
let request = client.new_request().with_program(ECHO_ELF).with_stdin(echo_message.as_bytes());
// Submit the request directly
let (request_id, expires_at) = client.submit_offchain(request).await?; // [!code hl]
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_11_test() {
use anyhow::Result;
use alloy_primitives::utils::parse_ether;
use boundless_market::{Client, request_builder::OfferParams};
async fn create_proof_request(
client: Client,
program: &'static [u8],
input: &[u8]) -> Result<()> {
// Create a request using new_request
let request = client.new_request()
  .with_program(program)
  .with_stdin(input)
  .with_offer(
    OfferParams::builder()
      // The market uses a reverse Dutch auction mechanism to match requests with provers.
      // Each request has a price range that a prover can bid on.
      .min_price(parse_ether("0.001")?)
      .max_price(parse_ether("0.002")?)
      // The timeout is the maximum number of blocks the request can stay
      // unfulfilled in the market before it expires. If a prover locks in
      // the request and does not fulfill it before the lock timeout, the
      // prover can be slashed.
      .timeout(1000)
      .lock_timeout(500)
      .ramp_up_period(100)
  );
// Submit the request directly
let (request_id, expires_at) = client.submit_onchain(request).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn request_mdx_12_test() {
use anyhow::Result;
use alloy::signers::local::PrivateKeySigner;
use alloy::primitives::utils::parse_units;
use boundless_market::{Client, storage::storage_provider_from_env};
use url::Url;
#[derive(Clone)]
struct Args {
rpc_url: Url,
private_key: PrivateKeySigner,
storage_config: String,
}
async fn create_boundless_client() -> Result<(), Box<dyn std::error::Error>> {
let args = Args {
rpc_url: "https://example.com".parse()?,
private_key: "0x0000000000000000000000000000000000000000000000000000000000000001".parse()?,
storage_config: "mock".to_string(),
};
// Configure the offer layer logic when building the client
let client = Client::builder()
  .with_rpc_url(args.rpc_url)
  .with_private_key(args.private_key)
  .with_storage_provider(Some(storage_provider_from_env()?))
  .config_offer_layer(|config| config
    // Set the price per cycle for automatic pricing calculations
    .max_price_per_cycle(parse_units("0.1", "gwei").unwrap())
    .min_price_per_cycle(parse_units("0.01", "gwei").unwrap())
    // Configure default timeouts and auction parameters
    .ramp_up_period(36)
    .lock_timeout(120)
    .timeout(300)
  )
  .build()
  .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn smart_contract_requestor_mdx_0_test() {
use boundless_market::contracts::RequestId;
use alloy::primitives::Address;
let smart_contract_requestor_address: Address = [0u8; 20].into();
let now = std::time::SystemTime::now()
    .duration_since(std::time::SystemTime::UNIX_EPOCH)
    .unwrap()
    .as_secs();
let days_since_epoch = (now / (24 * 60 * 60)) as u32;
let request_id = RequestId::new(smart_contract_requestor_address, days_since_epoch)
    .set_smart_contract_signed_flag();
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn smart_contract_requestor_mdx_1_test() {
use anyhow::{Result, Context};
use boundless_market::Client;
use boundless_market::input::GuestEnv;
use risc0_zkvm::default_executor;
use std::ops::Div;
// Function that takes the required parameters so we don't need to construct them
async fn example(
client: Client,
days_since_epoch: u32,
ECHO_ELF: &[u8]
) -> Result<()> {
// We encode the input as Big Endian, as this is how Solidity represents values. This simplifies validating
// the requirements of the request in the smart contract client.
let input = days_since_epoch.to_be_bytes();
let guest_env = GuestEnv::from_stdin(input);
let input_url = client
    .upload_input(&guest_env.encode()?)
    .await
    .context("failed to upload input")?;
// Execute the guest program locally to get the journal for use in our requirements
let env = guest_env.try_into()?;
let session_info = default_executor().execute(env, ECHO_ELF)?;
let journal = session_info.journal;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn smart_contract_requestor_mdx_2_test() {
use boundless_market::{Client, contracts::RequestId, request_builder::OfferParams};
use alloy::primitives::utils::parse_ether;
use alloy::primitives::Address;
use url::Url;
let smart_contract_requestor_address: Address = [0u8; 20].into();
let request_id = RequestId::new([0u8; 20].into(), 0)
.set_smart_contract_signed_flag();
async fn build_request(client: Client) -> anyhow::Result<()> {
let program_url = "https://example.com/image";
let input = "example input".as_bytes();
// Create the request params
let request = client.new_request()
    .with_program_url(program_url)?
    .with_stdin(input)
    .with_offer(
        OfferParams::builder()
            .min_price(parse_ether("0.001")?)
            .max_price(parse_ether("0.002")?)
            .lock_timeout(1000)
            .timeout(2000)
    );
// Build the request
let request = client.build_request(request).await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn smart_contract_requestor_mdx_3_test() {
use boundless_market::{Client, contracts::ProofRequest};
use alloy::primitives::Bytes;
use alloy::sol_types::SolValue;
async fn submit_request(
client: Client,
request: ProofRequest
) -> anyhow::Result<()> {
let signature: Bytes = request.abi_encode().into();
let (request_id, expires_at) =
    client.submit_request_onchain_with_signature(&request, signature).await?;
tracing::info!("Request {:x} submitted", request_id);
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn tracking_mdx_0_test() {
use boundless_market::{Client, StorageProviderConfig};
use boundless_market::request_builder::OfferParams;
use std::time::Duration;
use anyhow::Result;
use alloy_primitives::U256;
use alloy::signers::local::PrivateKeySigner;
async fn example() -> Result<()> {
let private_key = PrivateKeySigner::random();
let client = Client::builder().with_private_key(private_key).build().await?;
let program = vec![0u8; 32]; // Example program bytes
let input = vec![]; // Example input
let offer_params = OfferParams::builder(); // Example offer parameters
// Submit your request
let request = client.new_request()
    .with_program(program)
    .with_stdin(input)
    .with_offer(offer_params);
let (request_id, expires_at) = client.submit_onchain(request).await?;
// Wait for the request to be fulfilled
tracing::info!("Waiting for request {:x} to be fulfilled", request_id);
let fulfillment = client
    .wait_for_request_fulfillment(
        request_id,
        Duration::from_secs(5), // check every 5 seconds
        expires_at,
    )
    .await?;
tracing::info!("Request {:x} fulfilled", request_id);
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn tracking_mdx_1_test() {
use boundless_market::client::ClientError;
use boundless_market::contracts::{boundless_market::MarketError, FulfillmentData};
use boundless_market::Client;
use std::time::Duration;
use alloy_primitives::U256;
use anyhow::Result;
async fn example() -> Result<()> {
let client = Client::builder().build().await?;
let request_id = U256::from(0); // Example request ID
let check_interval = Duration::from_secs(5);
let expires_at = 0u64; // Example expiry time
match client.wait_for_request_fulfillment(request_id, check_interval, expires_at).await {
    Ok(fulfillment) => {
        // Process the fulfilled proof
        tracing::info!("Proof received with fulfillment data: {:?}", fulfillment.data()?);
    }
    Err(ClientError::MarketError(MarketError::RequestHasExpired(_))) => {
        tracing::error!("Request expired before fulfillment");
        // Handle expiration - maybe retry with different parameters
    }
    Err(e) => {
        tracing::error!("Request tracking failed: {}", e);
        // Handle other errors
    }
}
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn tracking_mdx_2_test() {
use boundless_market::contracts::RequestStatus;
use boundless_market::Client;
use alloy_primitives::U256;
use anyhow::Result;
use std::time::Duration;
async fn example() -> Result<()> {
let client = Client::builder().build().await?;
let request_id = U256::from(0); // Example request ID
let expires_at = 0u64; // Example expiry time
// Check status once
let status = client.boundless_market.get_status(request_id, Some(expires_at)).await?;
match status {
    RequestStatus::Fulfilled => {
        // Retrieve the fulfillment for the fulfilled request
        let fulfillment = client
            .wait_for_request_fulfillment(request_id, Duration::from_secs(1), expires_at)
            .await?;
    }
    RequestStatus::Locked => {
        tracing::info!("Request locked by a prover, awaiting fulfillment");
    }
    RequestStatus::Expired => {
        tracing::warn!("Request has expired");
    }
    RequestStatus::Unknown => {
        tracing::info!("Request is open for bidding");
    }
}
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn use_mdx_0_test() {
use std::time::Duration;
use alloy_primitives::U256;
use anyhow::Result;
use boundless_market::client::Client;
async fn wait_for_request_fulfillment(
request_id: U256,
expires_at: u64) -> Result<()> {
let boundless_client = Client::builder().build().await?;
let fulfillment = boundless_client
    .wait_for_request_fulfillment(request_id, Duration::from_secs(5), expires_at)
    .await?;
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn use_mdx_1_test() {
use alloy_primitives::Address;
use anyhow::Result;
use boundless_market::client::Client;
struct Args {
even_number_address: Address,
number: u64,
}
alloy::sol!(
#[sol(rpc, all_derives)]
interface IEvenNumber {
function set(uint256 x, bytes calldata seal);
}
);
async fn run(args: Args) -> Result<()> {
let boundless_client = Client::builder().build().await?;
let even_number = IEvenNumber::new(
    args.even_number_address,
    boundless_client.provider().clone(),
);
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn use_mdx_2_test() {
use alloy_primitives::{Address, Bytes, U256};
use anyhow::Result;
use boundless_market::client::Client;
struct Args {
even_number_address: Address,
number: u64,
}
alloy::sol!(
#[sol(rpc, all_derives)]
interface IEvenNumber {
function set(uint256 x, bytes calldata seal);
}
);
async fn run(args: Args) -> Result<()> {
let boundless_client = Client::builder().build().await?;
let even_number = IEvenNumber::new(
args.even_number_address,
boundless_client.provider().clone(),
);
let seal = Bytes::default();
let set_number = even_number
    .set(U256::from(args.number), seal)
    .from(boundless_client.caller());
Ok(())
}
}

#[test]
#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]
fn use_mdx_3_test() {
use std::time::Duration;
use alloy_primitives::{Address, Bytes, U256};
use anyhow::{Context, Result};
use boundless_market::client::Client;
struct Args {
even_number_address: Address,
number: u64,
}
alloy::sol!(
#[sol(rpc, all_derives)]
interface IEvenNumber {
function set(uint256 x, bytes calldata seal);
}
);
async fn run(args: Args, TX_TIMEOUT: Duration) -> Result<()> {
let boundless_client = Client::builder().build().await?;
let even_number = IEvenNumber::new(
args.even_number_address,
boundless_client.provider().clone(),
);
let seal = Bytes::default();
let set_number = even_number
.set(U256::from(args.number), seal)
.from(boundless_client.caller());
let pending_tx = set_number.send().await.context("failed to broadcast tx")?;
let tx_hash = pending_tx
    .with_timeout(Some(TX_TIMEOUT))
    .watch()
    .await
    .context("failed to confirm tx")?;
tracing::info!("Tx {:?} confirmed", tx_hash);
Ok(())
}
}

