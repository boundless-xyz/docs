// Copyright 2025 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use glob::glob;
use regex::Regex;
use std::{fmt::Write, fs};

#[derive(Debug)]
struct RustSnippet {
    content: String,
    should_run: bool,
}

fn main() {
    let mut rust_code = String::from(
        r#"// ---------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
//
// This file is automatically generated by `build.rs`. It collects all Rust
// code snippets from the `.mdx` documentation files and turns them into
// runnable tests.
//
// Any manual edits will be overwritten on the next `cargo build` or `cargo test`.
//
// To make changes, edit the Rust snippets in the `.mdx` files directly.
// ---------------------------------------------------------------------------
"#,
    );
    let pattern = "../src/pages/**/*.mdx"; // Original glob
    for entry in glob(pattern).unwrap() {
        let path = entry.unwrap();
        println!("cargo:rerun-if-changed={}", path.display());

        let content = fs::read_to_string(&path).expect("Failed to read file");

        let snippets = extract_rust_snippets(&content);
        if snippets.is_empty() {
            continue;
        }

        let stem = path
            .file_stem()
            .unwrap()
            .to_str()
            .unwrap()
            .replace('-', "_");

        for (i, snippet) in snippets.iter().enumerate() {
            writeln!(rust_code, "#[test]").unwrap();
            if !snippet.should_run {
                writeln!(rust_code, "#[ignore]").unwrap();
            }

            writeln!(rust_code, "#[allow(dead_code, unused_assignments, unused_variables, unused_imports, unused_mut, non_snake_case)]").unwrap();
            writeln!(rust_code, "fn {stem}_mdx_{i}_test() {{").unwrap();
            writeln!(rust_code, "{}", snippet.content).unwrap();
            writeln!(rust_code, "}}").unwrap();
            writeln!(rust_code, "").unwrap(); // newline
        }
    }

    fs::write("src/generated_doctests.rs", rust_code).unwrap();
}

fn normalize_whitespace(text: &str) -> String {
    let lines: Vec<_> = text
        .lines()
        .filter(|line| !line.contains("....")) // Filter out lines containing ....
        .collect();

    if lines.is_empty() {
        return String::new();
    }

    let min_indent = lines
        .iter()
        .filter(|line| !line.trim().is_empty())
        .map(|line| line.len() - line.trim_start().len())
        .min()
        .unwrap_or(0);

    lines
        .iter()
        .map(|line| {
            if line.trim().is_empty() {
                ""
            } else {
                &line[min_indent.min(line.len() - line.trim_start().len())..]
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}

fn process_code_block(code: &str) -> String {
    let mut processed_lines = Vec::new();
    let normalized = normalize_whitespace(code);

    for line in normalized.lines() {
        let trimmed = line.trim_start();

        if let Some(content) = trimmed.strip_prefix("# ") {
            let content = content.trim_start();
            if !content.is_empty() {
                processed_lines.push(content.to_string());
            }
        } else if trimmed != "#" {
            let line = line.replace("// [!code focus]", "").trim_end().to_string();
            let line = line.replace("showLineNumbers", "").trim_end().to_string();
            if !line.trim().is_empty() {
                processed_lines.push(line);
            }
        }
    }
    processed_lines.join("\n")
}

fn extract_rust_snippets(content: &str) -> Vec<RustSnippet> {
    let re = Regex::new(r"```rust(?:\s+(ignore|no_run))?\s*((?:.|\n)*?)```").unwrap();
    re.captures_iter(content)
        .filter_map(|cap| {
            let flag = cap.get(1).map(|m| m.as_str());
            let code = cap.get(2)?.as_str().trim();

            match flag {
                Some("ignore") => None,
                Some("no_run") => Some(RustSnippet {
                    content: process_code_block(code),
                    should_run: false,
                }),
                _ => Some(RustSnippet {
                    content: process_code_block(code),
                    should_run: true,
                }),
            }
        })
        .collect()
}
